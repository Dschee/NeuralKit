//
//  DataImport.swift
//  NeuralKit
//
//  Created by Palle Klewitz on 02.03.17.
//  Copyright Â© 2016 - 2017 Palle Klewitz.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is furnished
//  to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
//  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
//  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

import Foundation
import Cocoa
import MatrixVector


// Extension providing a function to partition an array into a tuple of two arrays
fileprivate extension Array
{
	
	/// Partitions an array into two partitions based on the result of the provided `isInFirstPartition` function
	///
	/// - Parameter isInFirstPartition: Determines if an element should be in the first partition. 
	/// If the function returns true, an element will be in the first partition, otherwise it will be in the second partition.
	/// - Returns: Two disjunct arrays generated by partitioning the array.
	func partition(by isInFirstPartition: (Element) throws -> Bool) rethrows -> ([Element], [Element])
	{
		let firstPartition  = try self.filter{try  isInFirstPartition($0)}
		let secondPartition = try self.filter{try !isInFirstPartition($0)}
		return (firstPartition, secondPartition)
	}
	
	
	/// Performs a parallel map operation on the array using the provided transform function.
	/// This should only be used if the amount of work on each element is very high.
	///
	/// - Parameter transform: Transforms an element of the source collection into an element of the result
	/// - Returns: Array generated by applying the transform on each element of the source array.
	func pmap<Result>(_ transform: @escaping (Element) -> Result) -> [Result]
	{
		var result = Array<Result?>(repeating: nil, count: self.count)
		DispatchQueue.concurrentPerform(iterations: self.count)
		{ index in
			result[index] = transform(self[index])
		}
		return result.flatMap{$0}
	}
	
	
	/// Performs a parallel flat map operation on the array using the provided transform function.
	/// This should only be used if the amount of work on each element is very high.
	///
	/// - Parameter transform: Transforms an element of the source collection into an element of the result
	/// - Returns: Array generated by applying the transform on each element of the source array and flattening the result
	func pflatMap<Result>(_ transform: @escaping (Element) -> [Result]) -> [Result]
	{
		return pmap(transform).flatMap{$0}
	}
	
	
	/// Performs a parallel flat map operation on the array using the provided transform function.
	/// This should only be used if the amount of work on each element is very high.
	///
	/// - Parameter transform: Transforms an element of the source collection into an element of the result
	/// - Returns: Array generated by applying the transform on each element of the source array and filtering out nil values.
	func pflatMap<Result>(_ transform: @escaping (Element) -> Result?) -> [Result]
	{
		return pmap(transform).flatMap{$0}
	}
	
}


public struct DirectoryImageSetImporter
{
	/// Label of a training sample.
	/// The label will be equal to the path of the folder it is contained in
	public typealias Label = String
	
	/// Imports all training samples from the given directory.
	///
	/// The training samples must be stored as images in either PNG or JPG format.
	///
	/// - Parameters:
	///   - directory: Directory to import samples from
	///   - baseOutputValue: Output in the training samples used if an output does not correspond to the label of a sample
	///   - hotOutputValue: Output in the training samples used if an output represents the label of a sample
	///   - includeFile: Decides if a file should be imported. True by default.
	///   - label: Label for a sample. By default, the path to the file excluding the filename itself will be used.
	///			   Samples with equal labels will be grouped together.
	///   - pixelDataOfImage: Retrieves the pixel data of an image and converts it to a Matrix3. 
	///			   By default, the greyscale image of the matrix will be used.
	/// - Returns: List of samples and their corresponding label
	/// - Throws: Throws an error if the contents of the directory, its subdirectories or files could not be read.
	public static func `import`(
		from directory: URL,
		baseOutputValue: Float = 0,
		hotOutputValue: Float = 1,
		includeFile: @escaping (URL) throws -> Bool = {_ in true},
		label: @escaping (URL) throws -> String = {$0.path},
		pixelDataOfImage: @escaping (CGImage) -> Matrix3? = {$0.greyscaleMatrix}
	) throws -> [(TrainingSample, Label)]
	{
		
		/// Determines if a file exists at the given path and is a directory
		///
		/// - Parameter file: File path to check
		/// - Returns: True, if a directory exists at the given path
		func isDirectory(file: URL) -> Bool
		{
			var isDirectory = ObjCBool(false)
			guard FileManager.default.fileExists(atPath: file.path, isDirectory: &isDirectory) else { return false }
			return isDirectory.boolValue
		}
		
		
		/// Recursively loads all samples from the directory and all of its subdirectories.
		///
		/// - Parameter directory: Directory to scan
		/// - Returns: List of samples and their labels contained in the directory and its subdirectories
		func loadContents(of directory: URL) throws -> [(Matrix3, String)]
		{
			let (directories, files) = try FileManager
				.default
				.contentsOfDirectory(at: directory, includingPropertiesForKeys: nil, options: .skipsHiddenFiles)
				.filter(includeFile)
				.partition(by: isDirectory)
			
			let images = try files
				.lazy
				.map{try Data(contentsOf: $0)}
				.flatMap{NSBitmapImageRep(data: $0)}
				.flatMap{$0.cgImage}
				.pflatMap(pixelDataOfImage)
			
			let subdirectoryImages = try directories.flatMap(loadContents(of:))
			
			if files.isEmpty
			{
				return subdirectoryImages
			}
			
			let directoryLabel = try label(directory)
			let labelledImages = images.map{($0, directoryLabel)}
			
			return labelledImages + subdirectoryImages
		}
		
		// Load contents of the base directory and convert them into matrices
		let labelledImages = try loadContents(of: directory)
		
		// Determine unique labels and sort them alphabetically
		let uniqueOrderedLabels = Set(labelledImages.map{$0.1}).sorted()
		
		return labelledImages.flatMap
		{ (matrix, label) -> (TrainingSample, String)? in
			// Creating training sample based on the input matrix and its index in the sorted lists of labels
			guard let index = uniqueOrderedLabels.index(of: label) else { return nil }
			return (
				TrainingSample(
					values: matrix,
					outputCount: uniqueOrderedLabels.count,
					targetIndex: index,
					baseValue: baseOutputValue,
					hotValue: hotOutputValue
				),
				label
			)
		}
	}
}
