//
//  VectorCore.swift
//  NeuralKit
//
//  Created by Palle Klewitz on 19.02.17.
//
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//	copies of the Software, and to permit persons to whom the Software is
//	furnished to do so, subject to the following conditions:
//
//	The above copyright notice and this permission notice shall be included in all
//	copies or substantial portions of the Software.
//
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//	SOFTWARE.


import Foundation
import Accelerate

/// Operator for component wise division of a vector.
infix operator &/ : MultiplicationPrecedence


// Vector - Vector arithmetic

/// Calculates the dot product of two vectors.
///
/// - Parameters:
///   - lhs: First input vector
///   - rhs: Second input vector
/// - Returns: The dot product of the input vectors
public func * (lhs: [Float], rhs: [Float]) -> Float
{
	var output: Float = 0
	vDSP_dotpr(lhs, 1, rhs, 1, &output, UInt(lhs.count))
	return output
}


/// Performs a component wise addition of two input vectors
///
/// - Parameters:
///   - lhs: First input vector
///   - rhs: Second input vector
/// - Returns: Output vector generated by adding the input vectors component wise.
public func &+ (lhs: [Float], rhs: [Float]) -> [Float]
{
	precondition(lhs.count == rhs.count, "Vector lengths must be equal")
	var output = [Float](repeating: 0, count: lhs.count)
	vDSP_vadd(lhs, 1, rhs, 1, &output, 1, UInt(lhs.count))
	return output
}


/// Performs a component wise subtraction of two input vectors
///
/// - Parameters:
///   - lhs: First input vector
///   - rhs: Second input vector
/// - Returns: Output vector generated by subtracting the input vectors component wise.
public func &- (lhs: [Float], rhs: [Float]) -> [Float]
{
	precondition(lhs.count == rhs.count, "Vector lengths must be equal")
	var output = [Float](repeating: 0, count: lhs.count)
	vDSP_vsub(lhs, 1, rhs, 1, &output, 1, UInt(lhs.count))
	return output
}


/// Performs a component wise multiplication of two input vectors
///
/// - Parameters:
///   - lhs: First input vector
///   - rhs: Second input vector
/// - Returns: Output vector generated by multiplying the input vectors component wise.
public func &* (lhs: [Float], rhs: [Float]) -> [Float]
{
	precondition(lhs.count == rhs.count, "Vector lengths must be equal")
	var output = [Float](repeating: 0, count: lhs.count)
	vDSP_vmul(lhs, 1, rhs, 1, &output, 1, UInt(lhs.count))
	return output
}


/// Performs a component wise division of two input vectors
///
/// - Parameters:
///   - lhs: First input vector
///   - rhs: Second input vector
/// - Returns: Output vector generated by dividing the input vectors component wise.
public func &/ (lhs: [Float], rhs: [Float]) -> [Float]
{
	precondition(lhs.count == rhs.count, "Vector lengths must be equal")
	var output = [Float](repeating: 0, count: lhs.count)
	vDSP_vdiv(lhs, 1, rhs, 1, &output, 1, UInt(lhs.count))
	return output
}


// Vector - Scalar arithmetic


/// Performs a component wise addition of an input vector with a scalar
///
/// - Parameters:
///   - lhs: Input vector
///   - rhs: Input scalar
/// - Returns: Output vector generated by adding the input scalar to the components of the input vector.
public func &+ (lhs: [Float], rhs: Float) -> [Float]
{
	var output = [Float](repeating: 0, count: lhs.count)
	vDSP_vsadd(lhs, 1, [rhs], &output, 1, UInt(lhs.count))
	return output
}


/// Performs a component wise subtraction of an input vector with a scalar
///
/// - Parameters:
///   - lhs: Input vector
///   - rhs: Input scalar
/// - Returns: Output vector generated by subtracting the input scalar from the components of the input vector.
public func &- (lhs: [Float], rhs: Float) -> [Float]
{
	var output = [Float](repeating: 0, count: lhs.count)
	vDSP_vsadd(lhs, 1, [-rhs], &output, 1, UInt(lhs.count))
	return output
}


/// Performs a component wise multiplication of an input vector with a scalar
///
/// - Parameters:
///   - lhs: Input vector
///   - rhs: Input scalar
/// - Returns: Output vector generated by multiplying the input scalar with the components of the input vector.
public func &* (lhs: [Float], rhs: Float) -> [Float]
{
	var output = [Float](repeating: 0, count: lhs.count)
	vDSP_vsmul(lhs, 1, [rhs], &output, 1, UInt(lhs.count))
	return output
}


/// Performs a component wise division of an input vector with a scalar
///
/// - Parameters:
///   - lhs: Input vector
///   - rhs: Input scalar
/// - Returns: Output vector generated by dividing the input vector by the input scalar
public func &/ (lhs: [Float], rhs: Float) -> [Float]
{
	var output = [Float](repeating: 0, count: lhs.count)
	vDSP_vsdiv(lhs, 1, [rhs], &output, 1, UInt(lhs.count))
	return output
}


// Scalar - Vector arithmetic

/// Performs a component wise addition of an input vector and a scalar
///
/// - Parameters:
///   - lhs: Input scalar
///   - rhs: Input vector
/// - Returns: Output vector generated by adding the input scalar to every element of the input vector.
public func &+ (lhs: Float, rhs: [Float]) -> [Float]
{
	var output = [Float](repeating: 0, count: rhs.count)
	vDSP_vsadd(rhs, 1, [lhs], &output, 1, UInt(rhs.count))
	return output
}


/// Performs a component wise subtraction of an input scalar and a vector
///
/// - Parameters:
///   - lhs: Input scalar
///   - rhs: Input vector
/// - Returns: Output vector generated by subtracting every element from the input scalar.
public func &- (lhs: Float, rhs: [Float]) -> [Float]
{
	var output = [Float](repeating: 0, count: rhs.count)
	vDSP_vneg(rhs, 1, &output, 1, UInt(rhs.count))
	vDSP_vsadd(output, 1, [lhs], &output, 1, UInt(rhs.count))
	return output
}


/// Performs a component wise multiplication of an input vector and a scalar
///
/// - Parameters:
///   - lhs: Input scalar
///   - rhs: Input vector
/// - Returns: Output vector generated by multiplying the input scalar with every element of the input vector.
public func &* (lhs: Float, rhs: [Float]) -> [Float]
{
	var output = [Float](repeating: 0, count: rhs.count)
	vDSP_vsmul(rhs, 1, [lhs], &output, 1, UInt(rhs.count))
	return output
}


/// Performs a component wise division of an input scalar and a vector
///
/// - Parameters:
///   - lhs: Input scalar
///   - rhs: Input vector
/// - Returns: Output vector generated by dividing the input scalar by every element of the input vector.
public func &/ (lhs: Float, rhs: [Float]) -> [Float]
{
	var output = [Float](repeating: 0, count: rhs.count)
	vDSP_svdiv([lhs], rhs, 1, &output, 1, UInt(rhs.count))
	return output
}


// Vector functions commonly used in neural networks

/// Calculates the element wise square root of an input vector
///
/// - Parameter values: Input vector
/// - Returns: Output vector containing the roots of every element of the input vector
public func sqrt(_ values: [Float]) -> [Float]
{
	var output = [Float](repeating: 0, count: values.count)
	vvsqrtf(&output, values, [Int32(values.count)])
	return output
}


/// Calculates the exponential function e^x for every element x of the input vector
///
/// - Parameter values: Input vector
/// - Returns: Output vector containing the exponentiated elements of the input vector
public func exp(_ values: [Float]) -> [Float]
{
	var output = [Float](repeating: 0, count: values.count)
	vvexpf(&output, values, [Int32(values.count)])
	return output
}


/// Calculates the tangens hyperbolicus for every element of the input vector
///
/// - Parameter values: Input vector
/// - Returns: Output vector containing the tangens hyperbolicus of every element from the input vector
public func tanh(_ values: [Float]) -> [Float]
{
	var output = [Float](repeating: 0, count: values.count)
	vvtanhf(&output, values, [Int32(values.count)])
	return output
}


/// Calculates the derivative of the tangens hyperbolicus for every element of the input vector.
///
/// **Note:** The input vector must consist of output values from the tanh function.
///
/// - Parameter values: Values for which the derivative of the tangens hyperbolicus should be calculated
/// - Returns: The derivative of the tangens hyperbolicus of every element in the input vector.
public func tanh_deriv(_ values: [Float]) -> [Float]
{
	var output = [Float](repeating: 0, count: values.count)
	vDSP_vsq(values, 1, &output, 1, vDSP_Length(values.count))
	vDSP_vneg(output, 1, &output, 1, vDSP_Length(values.count))
	vDSP_vsadd(output, 1, [1], &output, 1, vDSP_Length(values.count))
	return output
}


/// Calcualtes the natural logarithm of every element of the input vector
///
/// - Parameter values: Input vector
/// - Returns: Output vector containing the natural logarithm of every element from the input vector
public func log(_ values: [Float]) -> [Float]
{
	var output = [Float](repeating: 0, count: values.count)
	vvlogf(&output, values, [Int32(values.count)])
	return output
}


/// Computes a rectified linear unit activation function
/// The output values will be equal to max(input, 0)
///
/// - Parameter values: Input vector
/// - Returns: Output values generated by applying max(input, 0) to each value of the input vector.
public func relu(_ values: [Float]) -> [Float]
{
	var output = [Float](repeating: 0, count: values.count)
	vDSP_vthres(values, 1, [0], &output, 1, UInt(values.count))
	return output
}


/// Computes the derivative of a rectified linear unit activation function
/// Using raw input values or output values of the rectified linear unit function
///
/// - Parameter values: Input vector
/// - Returns: Output values generated by calculating the derivative 
/// of the rectified linear unit function for each value of the input vector.
public func relu_deriv(_ values: [Float]) -> [Float]
{
	var output = [Float](repeating: 0, count: values.count)
	vDSP_vclip(values, 1, [0], [1], &output, 1, UInt(values.count))
	vvceilf(&output, output, [Int32(values.count)])
	return output
}
