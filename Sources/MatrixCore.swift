//
//  MatrixCore.swift
//  NeuralKit
//
//  Created by Palle Klewitz on 19.02.17.
//
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//	copies of the Software, and to permit persons to whom the Software is
//	furnished to do so, subject to the following conditions:
//	
//	The above copyright notice and this permission notice shall be included in all
//	copies or substantial portions of the Software.
//	
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//	SOFTWARE.

import Foundation
import Accelerate


// Offset extension
fileprivate extension CountableRange where Bound: Integer
{
	
	/// Offsets the range by a given amount
	/// For example (0 ..< 10).offset(5) equals 5 ..< 15
	///
	/// - Parameter offset: Offset
	/// - Returns: Range generated by shifting the initial range by a given offset
	func withOffset(_ offset: Bound) -> CountableRange<Bound>
	{
		return CountableRange<Bound>(uncheckedBounds: (lower: (offset + self.startIndex), upper: offset + self.endIndex))
	}
	
}


/// A two dimensional matrix
public struct Matrix
{
	
	/// Values stored in the matrix as a flattened array. 
	/// The value of the nth row and mth column is at index `n * width + m`
	var values: [Float]
	
	/// Width of the matrix
	/// If the width is zero, the matrix is empty for any height
	let width: Int
	
	
	/// Height of the matrix
	/// If the height is zero, the matrix is empty for any width
	let height: Int
	
	
	/// Creates a new matrix with a given width and height
	/// containing the given values.
	/// The value stored at a row n and a column n must be at index `n * width + m` in the input vector.
	///
	/// The product of width and height must be equal to the number of elements in the input vector.
	///
	/// - Parameters:
	///   - values: Input vector containing the matrix values
	///   - width: Width of the matrix
	///   - height: Height of the matrix
	public init(values: [Float], width: Int, height: Int)
	{
		precondition(width * height == values.count, "Matrix dimensions are incorrect")
		self.values = values
		self.width = width
		self.height = height
	}
	
	
	/// Creates a new matrix with the given rows.
	///
	/// - Parameter rows: row vectors of equal length
	public init(rows: [[Float]])
	{
		self.values = rows.flatMap{$0}
		self.width = rows.first?.count ?? 0
		self.height = rows.count
		
		// The following line crashes the compiler.
//		assert(rows.reduce(true, {$0 && $1.count == self.width}), "The length of all rows must be equal")
	}
	
	
	/// Multiplies a matrix with another matrix.
	/// The resulting matrix will have a width equal to the height of the left matrix 
	/// and a height equal to the width of the right matrix.
	///
	/// The width of the left matrix must be equal to the height of the right matrix
	///
	/// - Parameters:
	///   - lhs: Left matrix
	///   - rhs: Right matrix
	/// - Returns: A matrix generated by multiplying the left matrix with the right matrix
	public static func * (lhs: Matrix, rhs: Matrix) -> Matrix
	{
		var result = [Float](repeating: 0, count: lhs.height * rhs.width)
		vDSP_mmul(lhs.values, 1, rhs.values, 1, &result, 1, vDSP_Length(lhs.height), vDSP_Length(rhs.width), vDSP_Length(lhs.width))
		return Matrix(values: result, width: lhs.height, height: rhs.width)
	}
	
	
	/// Multiplies a matrix with a vector
	///
	/// The width of the matrix must be equal to the length of the vector.
	/// The resulting vector will have a length equal to the height of the matrix
	///
	/// - Parameters:
	///   - lhs: Matrix to multiply
	///   - rhs: Vector, which is multiplied with the matrix
	/// - Returns: A vector generated by multiplying the input matrix with the input vector
	public static func * (lhs: Matrix, rhs: [Float]) -> [Float]
	{
		var result = [Float](repeating: 0, count: lhs.height)
		cblas_sgemv(CblasRowMajor, CblasNoTrans, Int32(lhs.height), Int32(lhs.width), 1.0, lhs.values, Int32(lhs.width), rhs, 1, 1.0, &result, 1)
		return result
	}
	
	public subscript(x: Int, y: Int) -> Float
	{
		get
		{
			return values[width * y + x]
		}
		
		set (new)
		{
			values[width * y + x] = new
		}
	}
	
	public subscript(row row: Int) -> [Float]
	{
		get
		{
			return Array<Float>(values[(row * width) ..< ((row + 1) * width)])
		}
		
		set (new)
		{
			for i in 0 ..< width
			{
				values[row * width + i] = new[i]
			}
		}
	}
	
	public subscript(column column: Int) -> [Float]
	{
		get
		{
			var result = [Float](repeating: 0, count: height)
			for y in (0 ..< height)
			{
				result[y] = values[width * y + column]
			}
			return result
		}
		
		set (new)
		{
			for i in 0 ..< height
			{
				values[width * i + column] = new[i]
			}
		}
	}
	
	public subscript(column column: Int, row row: Int, width width: Int, height height: Int) -> Matrix
	{
		get
		{
			var result = [Float](repeating: 0, count: width * height)
			for y in 0 ..< height
			{
				for x in 0 ..< width
				{
					result[width * y + x] = values[self.width * (row + y) + column + x]
				}
			}
			return Matrix(values: result, width: width, height: height)
		}
		
		set (new)
		{
			for y in 0 ..< height
			{
				for x in 0 ..< width
				{
					values[self.width * (row + y) + column + x] = new.values[width * y + x]
				}
			}
		}
	}
	
	public var transposed: Matrix
	{
		var result = [Float](repeating: 0, count: width * height)
		vDSP_mtrans(self.values, 1, &result, 1, vDSP_Length(width), vDSP_Length(height))
		return Matrix(values: result, width: height, height: width)
	}
	
	public func convolve(with other: Matrix) -> Float
	{
		return self.values * other.values
	}
}

public struct Matrix3
{
	var values: [Float]
	let width: Int
	let height: Int
	let depth: Int
	
	public var dimension:(width: Int, height: Int, depth: Int)
	{
		return (width: width, height: height, depth: depth)
	}
	
	public var indices:[(Int,Int,Int)]
	{
		func combine<BoundA: Comparable, BoundB: Comparable, BoundC: Comparable>(_ a: CountableRange<BoundA>, _ b: CountableRange<BoundB>, _ c: CountableRange<BoundC>) -> [(BoundA,BoundB,BoundC)]
		{
			return a.flatMap{elA in b.flatMap{elB in c.map{(elA,elB,$0)}}}
		}
		return combine(0..<width,0..<height,0..<depth)
	}
	
	public init(values: [Float], width: Int, height: Int, depth: Int)
	{
		precondition(width * height * depth == values.count, "Matrix dimensions are incorrect")
		self.values = values
		self.width = width
		self.height = height
		self.depth = depth
	}
	
	public init(values: [[[Float]]])
	{
		self.values = values.flatMap{$0.flatMap{$0}}
		self.width = values.first?.first?.count ?? 0
		self.height = values.first?.count ?? 0
		self.depth = values.count
	}
	
	public init(repeating value: Float, width: Int, height: Int, depth: Int)
	{
		self.values = [Float](repeating: value, count: width * height * depth)
		self.width = width
		self.height = height
		self.depth = depth
	}
	
	public subscript(x: Int, y: Int, z: Int) -> Float
	{
		get
		{
			return values[width * (height * z + y) + x]
		}
		
		set (new)
		{
			values[width * (height * z + y) + x] = new
		}
	}
	
	public subscript(x column: Int, y row: Int, z slice: Int, width width: Int, height height: Int, depth depth: Int) -> Matrix3
	{
		get
		{
			var result = Matrix3(repeating: 0, width: width, height: height, depth: depth)
			for (x,y,z) in result.indices
				where 0 ..< self.depth ~= z + slice && 0 ..< self.height ~= y + row && 0 ..< self.width ~= x + column
			{
				result[x,y,z] = self[x+column, y+row, z+slice]
			}
			return result
		}
		
		set (new)
		{
			for (x,y,z) in new.indices
				where 0 ..< self.depth ~= z + slice && 0 ..< self.height ~= y + row && 0 ..< self.width ~= x + column
			{
				values[self.width * (self.height * (slice + z) + row + y) + column + x] = new.values[width * (height * z + y) + x]
			}
		}
	}
	
	public func convolve(with other: Matrix3) -> Float
	{
		return self.values * other.values
	}
	
	public func reversed() -> Matrix3
	{
		return Matrix3(values: self.values.reversed(), width: self.width, height: self.height, depth: self.depth)
	}
}


extension Matrix: CustomStringConvertible
{
	public var description: String
	{
		return (0 ..< height).map
		{
			rowIndex in
			return (0 ..< width)
				.map{self[$0, rowIndex]}
				.map{"\($0)"}
				.joined(separator: "\t")
		}
		.joined(separator: "\n")
	}
}

extension Matrix3: CustomStringConvertible
{
	public var description: String
	{
		return (0 ..< depth).map
		{
			zIndex in
			return (0 ..< height).map
			{
				rowIndex in
				return (0 ..< width)
					.map{self[$0, rowIndex, zIndex]}
					.map{"\($0)"}
					.joined(separator: "\t")
			}
			.joined(separator: "\n")
		}
		.joined(separator: "\n\n")
	}
}

