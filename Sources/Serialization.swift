//
//  Serialization.swift
//  NeuralKit
//
//  Created by Palle Klewitz on 26.02.17.
//	Copyright (c) 2017 Palle Klewitz
//
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//	copies of the Software, and to permit persons to whom the Software is
//	furnished to do so, subject to the following conditions:
//
//	The above copyright notice and this permission notice shall be included in all
//	copies or substantial portions of the Software.
//
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//	SOFTWARE.

import Foundation


/// A collection of common encoding errors
///
/// - invalidType: The actual type is not equal to the expected type
/// - invalidValue: The value is not in the set of allowed values
/// - missingKey: The actual data does not contain a required key
public enum DecodingError: Error
{
	
	/// The actual type is not equal to the expected type.
	///
	/// - expected: Expected type described by a String
	/// - actual: Actual expression type
	case invalidType(expected: String, actual: Any)
	
	/// The value is not in the set of allowed values
	///
	/// - expected: Expected value or set of values described by a String
	/// - actual: Actual expression
	case invalidValue(expected: String, actual: Any)
	
	/// The data does not contain a required key.
	///
	/// - key: Required key
	/// - data: Data which should contain the key but does not.
	case missingKey(key: String, data: Any)
	
}


/// Protocol defining required methods for serialization and deserialization
public protocol Serializable
{
	
	/// Initializes a new instance of a serializable type.
	///
	/// - Parameter json: JSON Data
	/// - Throws: A decoding error if the data is invalid.
	init(json: Any) throws
	
	
	/// Serializes an existing instance of a serializable type
	/// into an expression which can be used by (NS)JSONSerialization.
	///
	/// Allowed types are primitive types (int, float, double, etc...), strings, arrays and dictionaries.
	///
	/// If another value should be stored in the serialized representation, it must implement
	/// the Serializable protocol and it must not be stored directly but using its serialized representation.
	///
	/// - Returns: A serialized representation which can be used by (NS)JSONSerialization
	func serialized() -> Any
	
}


/// Utility for encoding serializable values as JSON.
struct JSONCoder
{
	
	/// This initializer should not be used and has no effect.
	private init(){}
	
	
	/// Encodes a serializable expression as JSON data.
	///
	/// - Parameter value: Value which should be serialized
	/// - Returns: JSON data generated by serializing the given value
	/// - Throws: An error if the data could not be converted to JSON.
	/// This may happen if a value does not implement Serializable correctly and 
	/// generates a serializable expression which does contain types other than
	/// primitive types (int, float, double, etc...), strings, arrays or dictionaries.
	static func encode(_ value: Serializable) throws -> Data
	{
		let serialized = value.serialized()
		return try JSONSerialization.data(withJSONObject: serialized, options: .prettyPrinted)
	}
	
	
	/// Deserializes JSON data into an expression of the required type.
	///
	/// - Parameter data: JSON data
	/// - Returns: Deserialized value of the required type.
	/// - Throws: An error if the JSON data is syntactically incorrect,
	/// contains invalid values or is incomplete.
	static func decode<Deserialized: Serializable>(_ data: Data) throws -> Deserialized
	{
		let jsonData = try JSONSerialization.jsonObject(with: data, options: [])
		return try Deserialized(json: jsonData)
	}
}
