//
//  DataImport.swift
//  NeuralKit
//
//  Created by Palle Klewitz on 02.03.17.
//
//

import Foundation
import Cocoa

// Extension providing a function to partition an array into a tuple of two arrays
fileprivate extension Array
{
	
	/// Partitions an array into two partitions based on the result of the provided `isInFirstPartition` function
	///
	/// - Parameter isInFirstPartition: Determines if an element should be in the first partition. 
	/// If the function returns true, an element will be in the first partition, otherwise it will be in the second partition.
	/// - Returns: Two disjunct arrays generated by partitioning the array.
	func partition(by isInFirstPartition: (Element) throws -> Bool) rethrows -> ([Element], [Element])
	{
		let firstPartition  = try self.filter{try  isInFirstPartition($0)}
		let secondPartition = try self.filter{try !isInFirstPartition($0)}
		return (firstPartition, secondPartition)
	}
	
}


// /// A protocol defining methods required for importing a training set used for classification.
//public protocol ClassificationTrainingSetImporter
//{
//	/// Label of a training sample
//	associatedtype Label
//	
//	/// Imports all training samples from the given directory.
//	///
//	/// - Parameters:
//	///   - directory: Directory to import samples from
//	///   - baseOutputValue: Output in the training samples used if an output does not correspond to the label of a sample
//	///   - hotOutputValue: Output in the training samples used if an output represents the label of a sample
//	/// - Returns: List of samples and their corresponding label
//	/// - Throws: Throws an error if the contents of the directory, its subdirectories or files could not be read.
//	static func `import`(
//		from directory: URL,
//		baseOutputValue: Float,
//		hotOutputValue: Float,
//		includeFile: @escaping (URL) throws -> Bool,
//		label: @escaping (URL) throws -> String
//	) throws -> [(TrainingSample, Label)]
//}

public struct DirectoryImageSetImporter//: ClassificationTrainingSetImporter
{
	/// Label of a training sample.
	/// The label will be equal to the path of the folder it is contained in
	public typealias Label = String
	
	/// Imports all training samples from the given directory.
	///
	/// The training samples must be stored as images in either PNG or JPG format.
	///
	/// - Parameters:
	///   - directory: Directory to import samples from
	///   - baseOutputValue: Output in the training samples used if an output does not correspond to the label of a sample
	///   - hotOutputValue: Output in the training samples used if an output represents the label of a sample
	/// - Returns: List of samples and their corresponding label
	/// - Throws: Throws an error if the contents of the directory, its subdirectories or files could not be read.
	public static func `import`(
		from directory: URL,
		baseOutputValue: Float = 0,
		hotOutputValue: Float = 1,
		includeFile: @escaping (URL) throws -> Bool = {_ in true},
		label: @escaping (URL) throws -> String = {$0.path}
	) throws -> [(TrainingSample, Label)]
	{
		
		/// Determines if a file exists at the given path and is a directory
		///
		/// - Parameter file: File path to check
		/// - Returns: True, if a directory exists at the given path
		func isDirectory(file: URL) -> Bool
		{
			var isDirectory = ObjCBool(false)
			guard FileManager.default.fileExists(atPath: file.path, isDirectory: &isDirectory) else { return false }
			return isDirectory.boolValue
		}
		
		
		/// Recursively loads all samples from the directory and all of its subdirectories.
		///
		/// - Parameter directory: Directory to scan
		/// - Returns: List of samples and their labels contained in the directory and its subdirectories
		func loadContents(of directory: URL) throws -> [(Matrix3, String)]
		{
			let (directories, files) = try FileManager
				.default
				.contentsOfDirectory(at: directory, includingPropertiesForKeys: nil, options: .skipsHiddenFiles)
				.filter(includeFile)
				.partition(by: isDirectory)
			
			let images = try files
				.map{try Data(contentsOf: $0)}
				.flatMap{NSBitmapImageRep(data: $0)}
				.flatMap{$0.cgImage}
				.flatMap{$0.greyscaleMatrix}
			
			let directoryLabel = try label(directory)
			
			let labelledImages = images.map{($0, directoryLabel)}
			let subdirectoryImages = try directories.flatMap(loadContents(of:))
			
			return labelledImages + subdirectoryImages
		}
		
		// Load contents of the base directory and convert them into matrices
		let labelledImages = try loadContents(of: directory)
		
		// Determine unique labels and sort them alphabetically
		let uniqueOrderedLabels = Set(labelledImages.map{$0.1}).sorted()
		
		return labelledImages.flatMap
		{ (matrix, label) -> (TrainingSample, String)? in
			// Creating training sample based on the input matrix and its index in the sorted lists of labels
			guard let index = uniqueOrderedLabels.index(of: label) else { return nil }
			return (
				TrainingSample(
					values: matrix,
					outputCount: uniqueOrderedLabels.count,
					targetIndex: index,
					baseValue: baseOutputValue,
					hotValue: hotOutputValue
				),
				label
			)
		}
	}
}
