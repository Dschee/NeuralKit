//
//  DataImport.swift
//  NeuralKit
//
//  Created by Palle Klewitz on 02.03.17.
//
//

import Foundation

// Extension providing a function to partition an array into a tuple of two arrays
fileprivate extension Array
{
	
	/// Partitions an array into two partitions based on the result of the provided `isInFirstPartition` function
	///
	/// - Parameter isInFirstPartition: Determines if an element should be in the first partition. 
	/// If the function returns true, an element will be in the first partition, otherwise it will be in the second partition.
	/// - Returns: Two disjunct arrays generated by partitioning the array.
	func partition(by isInFirstPartition: (Element) throws -> Bool) rethrows -> ([Element], [Element])
	{
		let firstPartition  = try self.filter{try  isInFirstPartition($0)}
		let secondPartition = try self.filter{try !isInFirstPartition($0)}
		return (firstPartition, secondPartition)
	}
	
}


/// A protocol defining methods required for importing a training set used for classification.
protocol ClassificationTrainingSetImporter
{
	/// Label of a training sample
	associatedtype Label
	
	/// Imports all training samples from the given directory.
	///
	/// - Parameters:
	///   - directory: Directory to import samples from
	///   - baseOutputValue: Output in the training samples used if an output does not correspond to the label of a sample
	///   - hotOutputValue: Output in the training samples used if an output represents the label of a sample
	/// - Returns: List of samples and their corresponding label
	/// - Throws: Throws an error if the contents of the directory, its subdirectories or files could not be read.
	static func `import`(from directory: String, baseOutputValue: Float, hotOutputValue: Float) throws -> [(TrainingSample, Label)]
}

struct DirectoryImageSetImporter: ClassificationTrainingSetImporter
{
	/// Label of a training sample.
	/// The label will be equal to the path of the folder it is contained in
	typealias Label = String
	
	/// Imports all training samples from the given directory.
	///
	/// The training samples must be stored as images in either PNG or JPG format.
	///
	/// - Parameters:
	///   - directory: Directory to import samples from
	///   - baseOutputValue: Output in the training samples used if an output does not correspond to the label of a sample
	///   - hotOutputValue: Output in the training samples used if an output represents the label of a sample
	/// - Returns: List of samples and their corresponding label
	/// - Throws: Throws an error if the contents of the directory, its subdirectories or files could not be read.
	static func `import`(from directory: String, baseOutputValue: Float = 0, hotOutputValue: Float = 1) throws -> [(TrainingSample, Label)]
	{
		
		/// Determines if a file exists at the given path and is a directory
		///
		/// - Parameter file: File path to check
		/// - Returns: True, if a directory exists at the given path
		func isDirectory(file: String) throws -> Bool
		{
			var isDirectory = ObjCBool(false)
			guard FileManager.default.fileExists(atPath: directory, isDirectory: &isDirectory) else { return false }
			return isDirectory.boolValue
		}
		
		
		/// Recursively loads all samples from the directory and all of its subdirectories.
		///
		/// - Parameter directory: Directory to scan
		/// - Returns: List of samples and their labels contained in the directory and its subdirectories
		func loadContents(of directory: String) throws -> [(Matrix3, String)]
		{
			let (directories, files) = try FileManager
				.default
				.contentsOfDirectory(atPath: directory)
				.partition(by: isDirectory)
			
			let images = files
				.map(URL.init(fileURLWithPath:))
				.map{$0 as CFURL}
				.flatMap(CGDataProvider.init(url:))
				.flatMap
				{ dataProvider -> CGImage? in
					CGImage(pngDataProviderSource: dataProvider, decode: nil, shouldInterpolate: false, intent: .defaultIntent) ??
					CGImage(jpegDataProviderSource: dataProvider, decode: nil, shouldInterpolate: false, intent: .defaultIntent)
				}
				.flatMap{$0.colorMatrix}
			
			let labelledImages = images.map{($0, directory)}
			let subdirectoryImages = try directories.flatMap(loadContents(of:))
			
			return labelledImages + subdirectoryImages
		}
		
		// Load contents of the base directory and convert them into matrices
		let labelledImages = try loadContents(of: directory)
		
		// Determine unique labels and sort them alphabetically
		let uniqueOrderedLabels = Set(labelledImages.map{$0.1}).sorted()
		
		return labelledImages.flatMap
		{ (matrix, label) -> (TrainingSample, String)? in
			// Creating training sample based on the input matrix and its index in the sorted lists of labels
			guard let index = uniqueOrderedLabels.index(of: label) else { return nil }
			return (
				TrainingSample(
					values: matrix,
					outputCount: uniqueOrderedLabels.count,
					targetIndex: index,
					baseValue: baseOutputValue,
					hotValue: hotOutputValue
				),
				label
			)
		}
	}
}
